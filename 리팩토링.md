# 청소 리마인더 프로그램 리팩토링 문서

## 프로그램 개요

**청소 리마인더**는 매장(화정점)의 정기 청소 작업을 관리하고 알림하는 데스크톱 애플리케이션입니다. Tkinter를 기반으로 한 GUI 애플리케이션으로, 청소 작업의 주기적 관리, 알림, 히스토리 추적 등의 기능을 제공합니다.

## 핵심 기능

### 1. 청소 작업 관리
- **작업 등록/편집/삭제**: 청소 내용, 주기, 담당자 등 관리
- **카테고리 분류**: 제빙기, 커피머신, 튀김기, 블렌더, 냉장고, 기본 등 6개 대분류
- **우선순위 관리**: 높음/보통/낮음 3단계 우선순위
- **의존성 관리**: 작업 간 선후관계 설정 및 관리
- **체크리스트**: 세부 청소 항목 관리
- **링크 관리**: 청소 방법, 교육 동영상, 관련 문서 링크

### 2. 상태 계산 및 알림 시스템
- **상태 분류**: 정상/주의/지연 3단계 상태
- **자동 알림**: 
  - 청소 예정일 1일 전 사전 알림
  - 3일 이상 지연 시 긴급 알림
  - 일일 알림 (오전/오후/저녁 시간 설정 가능)
- **알림 방식**: 데스크톱 알림, 소리 알림, 팝업 알림
- **조용한 시간**: 특정 시간대 알림 중지 기능

### 3. 달력 뷰
- **월별 달력**: 청소 일정을 달력 형태로 시각화
- **상태 표시**: 완료/예정/지연 상태를 색상으로 구분
- **작업 완료**: 달력에서 직접 작업 완료 처리
- **통계 정보**: 월별 청소 통계 제공

### 4. 데이터 관리
- **JSON 기반 저장**: 사용자 AppData 폴더에 데이터 저장
- **백업 시스템**: 자동 백업 및 복원 기능
- **데이터 마이그레이션**: v1.0에서 v2.0 형식 자동 마이그레이션
- **데이터 검증**: 유효성 검사 및 오류 처리

## 데이터 구조

### TaskModel (작업 모델)
```json
{
  "cleaning_content": "청소 내용",
  "interval": 7,
  "last_cleaned": "2025-07-23",
  "cleaner": "담당자",
  "history": [{"date": "2025-07-23", "cleaner": "담당자"}],
  "postpone_days": 0,
  "postpone_reason": "",
  "category": "제빙기",
  "dependencies": [],
  "priority": "보통",
  "notes": "",
  "checklist": [],
  "instruction_url": "",
  "video_url": "",
  "document_url": "",
  "created_date": "2025-07-24",
  "updated_date": "2025-07-24"
}
```

### CategoryModel (카테고리 모델)
```json
{
  "name": "제빙기",
  "description": "제빙기 관련 청소 작업",
  "color": "#2196F3",
  "created_date": "2025-07-24"
}
```

### TemplateModel (템플릿 모델)
```json
{
  "name": "템플릿명",
  "description": "템플릿 설명",
  "tasks": [/* TaskModel 배열 */],
  "created_date": "2025-07-24"
}
```

## 웹 애플리케이션 구현 가이드

### 기술 스택
- **Frontend**: React + Next.js
- **Styling**: Tailwind CSS v4
- **State Management**: Zustand

### 핵심 컴포넌트 구조

#### 1. 데이터 모델 (TypeScript)
```typescript
interface Task {
  id: string;
  cleaningContent: string;
  interval: number;
  lastCleaned: string;
  cleaner: string;
  history: HistoryEntry[];
  postponeDays: number;
  postponeReason: string;
  category: string;
  dependencies: string[];
  priority: '높음' | '보통' | '낮음';
  notes: string;
  checklist: ChecklistItem[];
  instructionUrl: string;
  videoUrl: string;
  documentUrl: string;
  createdDate: string;
  updatedDate: string;
}

interface Category {
  id: string;
  name: string;
  description: string;
  color: string;
  createdDate: string;
}
```

#### 2. Zustand 스토어 구조
```typescript
interface AppStore {
  // 상태
  tasks: Task[];
  categories: Category[];
  templates: Template[];
  settings: Settings;
  
  // 액션
  addTask: (task: Task) => void;
  updateTask: (id: string, task: Partial<Task>) => void;
  deleteTask: (id: string) => void;
  completeTask: (id: string, cleaner: string) => void;
  postponeTask: (id: string, days: number, reason: string) => void;
  
  // 카테고리 관리
  addCategory: (category: Category) => void;
  updateCategory: (id: string, category: Partial<Category>) => void;
  deleteCategory: (id: string) => void;
  
  // 설정 관리
  updateSettings: (settings: Partial<Settings>) => void;
}
```

#### 3. 주요 페이지 구성
- **대시보드**: 오늘의 청소 작업, 지연된 작업, 통계
- **작업 목록**: 전체 작업 관리 (등록/편집/삭제)
- **달력 뷰**: 월별 청소 일정 시각화
- **카테고리 관리**: 대분류 관리
- **알림 설정**: 알림 방식 및 시간 설정
- **통계**: 청소 현황 분석

#### 4. 핵심 기능 구현

##### 상태 계산 유틸리티
```typescript
export const calculateTaskStatus = (task: Task) => {
  if (!task.lastCleaned) {
    return { status: 'overdue', color: '#C62828', daysInfo: '청소 기록 없음' };
  }
  
  const lastCleaned = new Date(task.lastCleaned);
  const nextDue = new Date(lastCleaned.getTime() + (task.interval + task.postponeDays) * 24 * 60 * 60 * 1000);
  const today = new Date();
  const daysDiff = Math.ceil((nextDue.getTime() - today.getTime()) / (24 * 60 * 60 * 1000));
  
  if (daysDiff < 0) {
    return { status: 'overdue', color: '#C62828', daysInfo: `${Math.abs(daysDiff)}일 지남` };
  } else if (daysDiff === 0) {
    return { status: 'warning', color: '#E65100', daysInfo: '오늘' };
  } else if (daysDiff <= 2) {
    return { status: 'warning', color: '#E65100', daysInfo: `${daysDiff}일 남음` };
  } else {
    return { status: 'normal', color: '#2E7D32', daysInfo: `${daysDiff}일 남음` };
  }
};
```

##### 알림 시스템
```typescript
export const useNotificationSystem = () => {
  const checkAdvanceNotifications = useCallback(() => {
    // 사전 알림 체크 로직
  }, []);
  
  const checkUrgentNotifications = useCallback(() => {
    // 긴급 알림 체크 로직
  }, []);
  
  const sendNotification = useCallback((title: string, message: string, type: 'info' | 'warning' | 'urgent') => {
    // 브라우저 알림 API 사용
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(title, {
        body: message,
        icon: '/icon.png'
      });
    }
  }, []);
  
  return { sendNotification, checkAdvanceNotifications, checkUrgentNotifications };
};
```

##### 달력 컴포넌트
```typescript
export const CalendarView = () => {
  const { tasks } = useAppStore();
  const [currentMonth, setCurrentMonth] = useState(new Date());
  
  const getTasksForDate = (date: Date) => {
    return tasks.filter(task => {
      const status = calculateTaskStatus(task);
      return status.nextDueDate && 
             new Date(status.nextDueDate).toDateString() === date.toDateString();
    });
  };
  
  return (
    <div className="calendar-container">
      {/* 달력 헤더 */}
      <div className="calendar-header">
        <button onClick={() => setCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() - 1))}>
          ◀
        </button>
        <h2>{currentMonth.getFullYear()}년 {currentMonth.getMonth() + 1}월</h2>
        <button onClick={() => setCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + 1))}>
          ▶
        </button>
      </div>
      
      {/* 달력 그리드 */}
      <div className="calendar-grid">
        {/* 달력 날짜들 */}
      </div>
    </div>
  );
};
```

### 5. 데이터 저장 및 동기화

#### 로컬 스토리지 활용
```typescript
export const useDataPersistence = () => {
  const saveData = useCallback((data: AppStore) => {
    localStorage.setItem('cleaning-reminder-data', JSON.stringify(data));
  }, []);
  
  const loadData = useCallback(() => {
    const saved = localStorage.getItem('cleaning-reminder-data');
    return saved ? JSON.parse(saved) : getDefaultData();
  }, []);
  
  return { saveData, loadData };
};
```

### 6. UI/UX 고려사항

#### 반응형 디자인
- 모바일 친화적 인터페이스
- 터치 제스처 지원
- 다크/라이트 테마 지원

#### 접근성
- 키보드 네비게이션 지원
- 스크린 리더 호환성
- 색상 대비 최적화

#### 성능 최적화
- 가상화된 리스트 (대량 작업 처리)
- 메모이제이션 활용
- 지연 로딩 구현

### 7. 추가 기능 제안

#### 웹 전용 기능
- **PWA 지원**: 오프라인 동작 및 설치 가능
- **실시간 동기화**: 여러 기기 간 데이터 동기화
- **공유 기능**: 작업 목록 공유 및 협업
- **백업/복원**: 클라우드 백업 서비스 연동
- **모바일 앱**: React Native로 모바일 앱 개발

#### 고급 기능
- **AI 추천**: 청소 패턴 분석 및 최적 일정 제안
- **리포트 생성**: 월/분기별 청소 리포트 자동 생성
- **QR 코드**: 청소 완료 확인용 QR 코드 시스템
- **IoT 연동**: 청소 기기 상태 모니터링

### 8. 마이그레이션 전략

#### 데이터 이식
1. JSON 데이터 파싱 및 변환
2. 카테고리 색상 매핑
3. 히스토리 데이터 보존
4. 설정값 이전

#### 기능 매핑
- Tkinter GUI → React 컴포넌트
- 파일 기반 저장 → 브라우저 스토리지/클라우드
- 데스크톱 알림 → 브라우저 알림 API
- 트레이 아이콘 → PWA 알림

이 리팩토링 문서를 참고하여 React + Next.js + Tailwind CSS v4 + Zustand 기반의 현대적인 웹 애플리케이션을 개발할 수 있습니다. 기존 Python 데스크톱 애플리케이션의 모든 핵심 기능을 웹 환경에 최적화하여 구현하면 됩니다.
